// Package ihex provides a library of structs for reading and writing Intel HEX files
// To learn more about the Intel HEX format, view the the Wikipedia article on the
// HEX file format at: https://en.wikipedia.org/wiki/Intel_HEX
package ihex

import (
	"bufio"
	"encoding/binary"
	"encoding/hex"
	"fmt"
	"io"
)

// File is the base interface for all IHEX file formats.
// All IHEX files must be able to do the following:
// Provide their file type.
// Read each record one at a time.
// Reset reading to the starting record of the file.
// Add one or more record(s) to the file.
type File interface {
	GetType() FileType
	ReadNext() (Record, bool)
	Reset()
	Add(r Record) error
	AddRecords(r ...Record) error
}

// WriteFile resets an IHEX file to the beginning record.
// Then it writes the file's contents in appropriate IHEX format to the provided writer.
// This also automatically handles creating checksums for each record in the file based on the record data.
// Returns any errors generated by the provided writer during the writing process.
func WriteFile(f File, w io.Writer) error {

	f.Reset()

	i := 1
	for r, ok := f.ReadNext(); ok; r, ok = f.ReadNext() {

		if err := r.write(w); err != nil {
			return fmt.Errorf("Error writing file at record %d: %s", i, err.Error())
		}
		i++
	}

	return nil
}

// NewFile reads the provided reader and creates an IHEX file based on the data.
// This automatically determines the IHEX file format based on the record types being read.
// Returns the new IHEX file generated from the reader data or and error if any errors were encountered during reading.
func NewFile(r io.Reader) (File, error) {

	currFileType := I8HEX
	records := make([]Record, 0)

	scanner := bufio.NewScanner(r)

	i := 0
	for scanner.Scan() {

		r, err := parseRecord(scanner.Text())

		if err != nil {
			return nil, &IndexedRecordError{
				Index:       i,
				RecordError: err,
			}
		}

		if currFileType == I8HEX {
			if r.Type == RecordExtSegment || r.Type == RecordStartSegment {
				currFileType = I16HEX
			} else if r.Type == RecordExtLinear || r.Type == RecordStartLinear {
				currFileType = I32HEX
			}
		}

		records = append(records, r)
	}

	var f File

	if currFileType == I16HEX {
		f = NewI16HEXFile()
	} else if currFileType == I32HEX {
		f = NewI32HEXFile()
	} else {
		f = NewI8HEXFile()
	}

	err := f.AddRecords(records...)

	return f, err
}

// parseRecord attempts to parse a line into a Record.
// Returns the newly read record or any errors encountered during parsing.
func parseRecord(line string) (Record, error) {

	record := Record{}

	if len(line) > recordMaximumSizeChars {
		return record, &InvalidRecordError{
			Message: fmt.Sprintf("Maximum record size is %d bytes. Record size detected: %d bytes", (recordMaximumSizeChars-1)/2, len(line)/2),
		}
	}

	if line[0] != recordStartChar {
		return record, &InvalidRecordError{
			Message: fmt.Sprintf("HEX record must begin with '%c'. Record starts with: '%c'", recordStartChar, line[0]),
		}
	}

	recordBytes, err := hex.DecodeString(line[1:])

	if err != nil {
		return record, &InvalidRecordError{
			Message: fmt.Sprintf("Unable to decode hexadecimal record contents: %s", err.Error()),
		}
	}

	dataSize := int(recordBytes[recordByteCountIndex])
	actualDataSize := len(recordBytes) - recordHeaderAndChecksumSize

	if dataSize != actualDataSize {
		return record, &InvalidRecordError{
			Message: fmt.Sprintf("Record byte count (%d) does not match actual detected byte count (%d)", dataSize, actualDataSize),
		}
	}

	record.AddressOffset = binary.BigEndian.Uint16(recordBytes[recordAddressByteIndex:2])
	record.Type = RecordType(recordBytes[recordRecordTypeIndex])

	if dataSize > 0 {
		record.Data = recordBytes[recordDataIndex:dataSize]

		checksum := recordBytes[recordDataIndex+dataSize]

		computedChecksum := record.getChecksum()

		if checksum != computedChecksum {
			return record, &InvalidRecordError{
				Message: fmt.Sprintf("Record checksum '%02X' does not match computed checksum '%02X'", checksum, computedChecksum),
			}
		}
	} else {
		record.Data = make([]byte, 0)
	}

	return record, nil
}
